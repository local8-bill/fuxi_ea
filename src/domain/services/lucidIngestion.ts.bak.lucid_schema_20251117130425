import fs from "fs";
import path from "path";

// Robust Lucid CSV ingestion
// - Logs CSV header
// - Writes full header to lucid_header_dump.txt at project root
// - Tries well-known Source/Target style columns
// - Falls back to "first two non-empty columns" per row
// - NEVER returns undefined; always { nodes: [], edges: [] }

const HEADER_DUMP_PATH = path.join(process.cwd(), "lucid_header_dump.txt");

export interface LucidNode {
  id: string;
  label: string;
  domain?: string | null;
  raw?: Record<string, string>;
}

export interface LucidEdge {
  id: string;
  sourceId: string;
  targetId: string;
  label?: string | null;
  raw?: Record<string, string>;
}

export interface LucidParseResult {
  nodes: LucidNode[];
  edges: LucidEdge[];
}

// Basic CSV → array of row objects
function parseCsvToRows(
  text: string
): { header: string[]; rows: Record<string, string>[] } {
  const trimmed = (text || "").trim();
  if (!trimmed) {
    console.warn("[LucidIngestion] Empty CSV text");
    return { header: [], rows: [] };
  }

  const lines = trimmed
    .split(/\r?\n/)
    .map((l) => l.trim())
    .filter((l) => l.length > 0);

  if (lines.length < 2) {
    console.warn("[LucidIngestion] CSV has header only or no lines", {
      lineCount: lines.length,
    });
    return { header: [], rows: [] };
  }

  const header = lines[0].split(",").map((h) => h.trim());
  console.log("[LucidIngestion] CSV header", { header });

  // Write header to file for debug
  try {
    fs.writeFileSync(HEADER_DUMP_PATH, JSON.stringify(header, null, 2), "utf8");
    console.log("[LucidIngestion] Header written to:", HEADER_DUMP_PATH);
  } catch (err) {
    console.warn("[LucidIngestion] Failed to write header dump", err);
  }

  const rows: Record<string, string>[] = [];

  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    if (!line) continue;

    // NOTE: simple split – assumes no embedded commas in quoted fields.
    const values = line.split(",").map((v) => v.trim());
    if (values.length === 1 && values[0] === "") continue;

    const row: Record<string, string> = {};
    for (let j = 0; j < header.length; j++) {
      row[header[j]] = values[j] ?? "";
    }
    rows.push(row);
  }

  console.log("[LucidIngestion] Parsed CSV rows", {
    rowCount: rows.length,
  });

  return { header, rows };
}

function getField(row: Record<string, string>, candidates: string[]): string | undefined {
  for (const c of candidates) {
    const hit = Object.keys(row).find(
      (k) => k.toLowerCase() === c.toLowerCase()
    );
    if (hit) {
      const value = row[hit]?.trim();
      if (value) return value;
    }
  }
  return undefined;
}

function fallbackSourceTarget(
  row: Record<string, string>
): { source?: string; target?: string } {
  const entries = Object.entries(row)
    .map(([k, v]) => [k, (v ?? "").trim()] as [string, string])
    .filter(([_, v]) => v.length > 0);

  if (entries.length < 2) {
    return {};
  }

  const [, sourceVal] = entries[0];
  const [, targetVal] = entries[1];

  return {
    source: sourceVal,
    target: targetVal,
  };
}

export function parseLucidCsv(csvText: string): LucidParseResult {
  console.log("[LucidIngestion] parseLucidCsv start", {
    textLength: csvText?.length ?? 0,
  });

  const { header, rows } = parseCsvToRows(csvText);
  const nodesMap = new Map<string, LucidNode>();
  const edges: LucidEdge[] = [];

  rows.forEach((row, idx) => {
    // Try explicit header names first
    let sourceName =
      getField(row, [
        "Source",
        "From",
        "Source System",
        "Source Application",
        "System A",
        "Application A",
      ]) ?? "";
    let targetName =
      getField(row, [
        "Target",
        "To",
        "Target System",
        "Target Application",
        "System B",
        "Application B",
      ]) ?? "";

    // If that fails, use fallback: first two non-empty columns in the row
    if (!sourceName || !targetName) {
      const fb = fallbackSourceTarget(row);
      if (!sourceName && fb.source) sourceName = fb.source;
      if (!targetName && fb.target) targetName = fb.target;
    }

    if (!sourceName || !targetName) {
      console.warn(
        "[LucidIngestion] Skipping row without usable source/target",
        {
          index: idx,
          row,
        }
      );
      return;
    }

    const sourceDomain =
      getField(row, ["Source Domain", "Domain A", "Domain"]) ?? null;
    const targetDomain =
      getField(row, ["Target Domain", "Domain B"]) ?? null;

    const label =
      getField(row, ["Integration Name", "Label", "Integration"]) ?? null;

    const sourceId = sourceName;
    const targetId = targetName;

    if (!nodesMap.has(sourceId)) {
      nodesMap.set(sourceId, {
        id: sourceId,
        label: sourceName,
        domain: sourceDomain,
        raw: row,
      });
    } else if (sourceDomain && !nodesMap.get(sourceId)!.domain) {
      nodesMap.get(sourceId)!.domain = sourceDomain;
    }

    if (!nodesMap.has(targetId)) {
      nodesMap.set(targetId, {
        id: targetId,
        label: targetName,
        domain: targetDomain,
        raw: row,
      });
    } else if (targetDomain && !nodesMap.get(targetId)!.domain) {
      nodesMap.get(targetId)!.domain = targetDomain;
    }

    const edge: LucidEdge = {
      id: `${sourceId}__${targetId}__${idx}`,
      sourceId,
      targetId,
      label,
      raw: row,
    };

    edges.push(edge);
  });

  const nodes = Array.from(nodesMap.values());

  console.log("[LucidIngestion] parseLucidCsv result", {
    nodeCount: nodes.length,
    edgeCount: edges.length,
  });

  const result: LucidParseResult = {
    nodes,
    edges,
  };

  return result;
}
