// Normalized Lucid CSV ingestion
// This implementation guarantees parseLucidCsv NEVER returns undefined
// and always returns an object with { nodes: [], edges: [] }.
// It is intentionally defensive and logs what it sees.

export interface LucidNode {
  id: string;
  label: string;
  domain?: string | null;
  raw?: Record<string, string>;
}

export interface LucidEdge {
  id: string;
  sourceId: string;
  targetId: string;
  label?: string | null;
  raw?: Record<string, string>;
}

export interface LucidParseResult {
  nodes: LucidNode[];
  edges: LucidEdge[];
}

// Basic CSV → array of row objects
function parseCsvToRows(text: string): Record<string, string>[] {
  const trimmed = (text || "").trim();
  if (!trimmed) {
    console.warn("[LucidIngestion] Empty CSV text");
    return [];
  }

  const lines = trimmed
    .split(/\r?\n/)
    .map((l) => l.trim())
    .filter((l) => l.length > 0);

  if (lines.length < 2) {
    console.warn("[LucidIngestion] CSV has header only or no lines", {
      lineCount: lines.length,
    });
    return [];
  }

  const header = lines[0].split(",").map((h) => h.trim());
  const rows: Record<string, string>[] = [];

  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    if (!line) continue;

    // NOTE: simple split – assumes no embedded commas in quoted fields.
    const values = line.split(",").map((v) => v.trim());
    if (values.length === 1 && values[0] === "") continue;

    const row: Record<string, string> = {};
    for (let j = 0; j < header.length; j++) {
      row[header[j]] = values[j] ?? "";
    }
    rows.push(row);
  }

  console.log("[LucidIngestion] Parsed CSV rows", {
    rowCount: rows.length,
  });

  return rows;
}

function getField(row: Record<string, string>, candidates: string[]): string | undefined {
  for (const c of candidates) {
    const hit = Object.keys(row).find(
      (k) => k.toLowerCase() === c.toLowerCase()
    );
    if (hit) {
      const value = row[hit]?.trim();
      if (value) return value;
    }
  }
  return undefined;
}

export function parseLucidCsv(csvText: string): LucidParseResult {
  console.log("[LucidIngestion] parseLucidCsv start", {
    textLength: csvText?.length ?? 0,
  });

  const rows = parseCsvToRows(csvText);
  const nodesMap = new Map<string, LucidNode>();
  const edges: LucidEdge[] = [];

  rows.forEach((row, idx) => {
    // Adjust these candidate lists to match your Lucid export headers as needed.
    const sourceName =
      getField(row, ["Source", "From", "Source System"]) ??
      getField(row, ["System A", "Application A"]) ??
      "";
    const targetName =
      getField(row, ["Target", "To", "Target System"]) ??
      getField(row, ["System B", "Application B"]) ??
      "";

    if (!sourceName || !targetName) {
      console.warn("[LucidIngestion] Skipping row without source/target", {
        index: idx,
        row,
      });
      return;
    }

    const sourceDomain =
      getField(row, ["Source Domain", "Domain A", "Domain"]) ?? null;
    const targetDomain =
      getField(row, ["Target Domain", "Domain B"]) ?? null;

    const label =
      getField(row, ["Label", "Integration", "Integration Name"]) ?? null;

    const sourceId = sourceName;
    const targetId = targetName;

    if (!nodesMap.has(sourceId)) {
      nodesMap.set(sourceId, {
        id: sourceId,
        label: sourceName,
        domain: sourceDomain,
        raw: row,
      });
    } else if (sourceDomain && !nodesMap.get(sourceId)!.domain) {
      nodesMap.get(sourceId)!.domain = sourceDomain;
    }

    if (!nodesMap.has(targetId)) {
      nodesMap.set(targetId, {
        id: targetId,
        label: targetName,
        domain: targetDomain,
        raw: row,
      });
    } else if (targetDomain && !nodesMap.get(targetId)!.domain) {
      nodesMap.get(targetId)!.domain = targetDomain;
    }

    const edge: LucidEdge = {
      id: `${sourceId}__${targetId}__${idx}`,
      sourceId,
      targetId,
      label,
      raw: row,
    };

    edges.push(edge);
  });

  const nodes = Array.from(nodesMap.values());

  console.log("[LucidIngestion] parseLucidCsv result", {
    nodeCount: nodes.length,
    edgeCount: edges.length,
  });

  // CRITICAL: Never return undefined. Always an object with nodes/edges arrays.
  const result: LucidParseResult = {
    nodes,
    edges,
  };

  return result;
}
