import type {
  DigitalEnterpriseView,
  DigitalEnterpriseNode,
  DigitalEnterpriseEdge,
  DigitalEnterpriseViewKind,
} from "@/domain/model/digitalEnterprise";

type ParseParams = {
  projectId: string;
  view: DigitalEnterpriseViewKind;
};

function splitCsvLine(line: string): string[] {
  const result: string[] = [];
  let current = "";
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const ch = line[i];

    if (ch === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }

    if (ch === "," && !inQuotes) {
      result.push(current);
      current = "";
      continue;
    }

    current += ch;
  }

  result.push(current);
  return result.map((c) => c.trim());
}

function normalizeLabel(label: string): string {
  return label.trim().replace(/\s+/g, " ");
}

export async function parseLucidCsv(
  content: string,
  params: ParseParams,
): Promise<DigitalEnterpriseView> {
  const lines = content
    .split(/\r?\n/)
    .map((l) => l.trim())
    .filter((l) => l.length > 0);

  if (lines.length < 2) {
    console.warn("[LUCID] CSV has no data rows, returning empty view");
    return {
      projectId: params.projectId,
      view: params.view,
      nodes: [],
      edges: [],
    };
  }

  const header = splitCsvLine(lines[0]);

  const idx = (name: string) =>
    header.findIndex((h) => h.toLowerCase() === name.toLowerCase());

  const idIdx = idx("Id");
  const nameIdx = idx("Name");
  const lineSourceIdx = idx("Line Source");
  const lineDestIdx = idx("Line Destination");

  if (idIdx === -1 || nameIdx === -1) {
    console.warn(
      "[LUCID] Missing Id/Name columns, returning empty view. Header=%o",
      header,
    );
    return {
      projectId: params.projectId,
      view: params.view,
      nodes: [],
      edges: [],
    };
  }

  const nodesById = new Map<string, DigitalEnterpriseNode>();
  const edges: DigitalEnterpriseEdge[] = [];

  for (let i = 1; i < lines.length; i++) {
    const cols = splitCsvLine(lines[i]);
    const rawId = cols[idIdx] ?? "";
    const rawName = cols[nameIdx] ?? "";
    const rawSrc = lineSourceIdx >= 0 ? cols[lineSourceIdx] ?? "" : "";
    const rawDst = lineDestIdx >= 0 ? cols[lineDestIdx] ?? "" : "";

    const id = rawId.trim();
    const name = rawName.trim();

    if (id && name && !nodesById.has(id)) {
      const label = normalizeLabel(name);
      nodesById.set(id, {
        id,
        label,
        rawLabel: name,
        kind: "system",
      } as DigitalEnterpriseNode);
    }

    if (rawSrc && rawDst) {
      const srcId = rawSrc.trim();
      const dstId = rawDst.trim();
      if (srcId && dstId && srcId !== dstId) {
        edges.push({
          id: `e-${srcId}-${dstId}-${i}`,
          from: srcId,
          to: dstId,
          kind: "integration",
        } as DigitalEnterpriseEdge);
      }
    }
  }

  const nodes = Array.from(nodesById.values());

  console.log(
    "[LUCID] Parsed view project=%s nodes=%d edges=%d",
    params.projectId,
    nodes.length,
    edges.length,
  );

  return {
    projectId: params.projectId,
    view: params.view,
    nodes,
    edges,
  };
}
