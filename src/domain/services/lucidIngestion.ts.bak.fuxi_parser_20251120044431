// Auto-generated by Fuxi parser upgrade script.
// Lucid CSV ingestion tuned for Lucidchart exports like "Future State Conceptual Architecture.csv"

export interface LucidNode {
  id: string;
  label: string;
  kind?: string | null;
  pageId?: string | null;
  domain?: string | null;
  raw?: Record<string, string>;
}

export interface LucidEdge {
  id: string;
  sourceId: string;
  targetId: string;
  label?: string | null;
  raw?: Record<string, string>;
}

export interface LucidParseResult {
  nodes: LucidNode[];
  edges: LucidEdge[];
  rawRows?: Record<string, string>[];
}

/**
 * Very small CSV parser that can handle:
 * - quoted fields
 * - commas inside quotes
 * - newlines between records
 */
function parseCsv(text: string): string[][] {
  const rows: string[][] = [];
  let current: string[] = [];
  let field = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    const next = i + 1 < text.length ? text[i + 1] : "";

    if (inQuotes) {
      if (ch === '"' && next === '"') {
        // Escaped quote
        field += '"';
        i++;
      } else if (ch === '"') {
        inQuotes = false;
      } else {
        field += ch;
      }
    } else {
      if (ch === '"') {
        inQuotes = true;
      } else if (ch === ",") {
        current.push(field);
        field = "";
      } else if (ch === "\n" || ch === "\r") {
        // End of record
        if (field.length > 0 || current.length > 0) {
          current.push(field);
          rows.push(current);
          current = [];
          field = "";
        }
        // swallow CRLF pairs
        if (ch === "\r" && next === "\n") {
          i++;
        }
      } else {
        field += ch;
      }
    }
  }

  if (field.length > 0 || current.length > 0) {
    current.push(field);
    rows.push(current);
  }

  return rows;
}

function normalizeHeader(name: string): string {
  return name.trim().toLowerCase();
}

function getColumnIndex(
  headerMap: Map<string, number>,
  candidates: string[],
): number | undefined {
  for (const c of candidates) {
    const idx = headerMap.get(c.toLowerCase());
    if (idx !== undefined) return idx;
  }
  return undefined;
}

function cleanLabel(raw: unknown): string {
  if (raw == null) return "";
  let s = String(raw).trim();
  // strip wrapping quotes
  while (s.startsWith('"') || s.startsWith("'")) {
    s = s.slice(1).trim();
  }
  while (s.endsWith('"') || s.endsWith("'")) {
    s = s.slice(0, -1).trim();
  }
  return s;
}

// Heuristic junk labels we don't want to treat as systems.
const JUNK_LABELS = new Set(
  [
    "document",
    "page",
    "new",
    "existing",
    "modified",
    "retire",
    "future",
    "systems / applications",
    "web services",
    "systems/applications",
    "legend",
  ].map((s) => s.toLowerCase()),
);

/**
 * Core Lucid parser – tuned for typical Lucidchart CSV export:
 *
 * Columns we understand (case-insensitive):
 * - "Id"
 * - "Name"
 * - "Shape Library"
 * - "Page ID"
 * - "Line Source"
 * - "Line Destination"
 * - "Text Area 1"
 * - "Text Area 2"
 */
export function parseLucidCsv(csvText: string): LucidParseResult {
  const rows = parseCsv(csvText);
  if (rows.length === 0) {
    return { nodes: [], edges: [] };
  }

  const header = rows[0];
  const headerMap = new Map<string, number>();
  header.forEach((h, idx) => {
    headerMap.set(normalizeHeader(h), idx);
  });

  const idIdx = getColumnIndex(headerMap, ["id"]);
  const nameIdx = getColumnIndex(headerMap, ["name"]);
  const shapeLibIdx = getColumnIndex(headerMap, ["shape library"]);
  const pageIdx = getColumnIndex(headerMap, ["page id", "page"]);
  const lineSrcIdx = getColumnIndex(headerMap, ["line source"]);
  const lineDstIdx = getColumnIndex(headerMap, ["line destination"]);
  const text1Idx = getColumnIndex(headerMap, ["text area 1"]);
  const text2Idx = getColumnIndex(headerMap, ["text area 2"]);
  const commentsIdx = getColumnIndex(headerMap, ["comments", "comment"]);
  const statusIdx = getColumnIndex(headerMap, ["status"]);

  const nodesById = new Map<string, LucidNode>();
  const edges: LucidEdge[] = [];
  const rawRows: Record<string, string>[] = [];

  for (let r = 1; r < rows.length; r++) {
    const row = rows[r];
    if (row.length === 0 || row.every((c) => c.trim() === "")) continue;

    const record: Record<string, string> = {};
    header.forEach((h, idx) => {
      record[h] = row[idx] ?? "";
    });
    rawRows.push(record);

    const idRaw = idIdx !== undefined ? row[idIdx] ?? "" : "";
    const id = idRaw.trim();
    if (!id) continue;

    const lineSrc = lineSrcIdx !== undefined ? row[lineSrcIdx] ?? "" : "";
    const lineDst = lineDstIdx !== undefined ? row[lineDstIdx] ?? "" : "";

    // Edge row: both source and destination present
    if (lineSrc.trim() || lineDst.trim()) {
      const sourceId = lineSrc.trim();
      const targetId = lineDst.trim();
      if (sourceId && targetId) {
        const labelParts: string[] = [];
        if (statusIdx !== undefined) {
          const st = cleanLabel(row[statusIdx]);
          if (st) labelParts.push(st);
        }
        if (text1Idx !== undefined) {
          const t1 = cleanLabel(row[text1Idx]);
          if (t1) labelParts.push(t1);
        }
        if (text2Idx !== undefined) {
          const t2 = cleanLabel(row[text2Idx]);
          if (t2) labelParts.push(t2);
        }

        const edgeLabel = labelParts.join(" • ") || undefined;

        edges.push({
          id,
          sourceId,
          targetId,
          label: edgeLabel,
          raw: record,
        });
      }
      continue;
    }

    // Node row
    let label = "";
    if (text1Idx !== undefined) {
      label = cleanLabel(row[text1Idx]);
    }
    if (!label && text2Idx !== undefined) {
      label = cleanLabel(row[text2Idx]);
    }
    if (!label && nameIdx !== undefined) {
      label = cleanLabel(row[nameIdx]);
    }

    const labelLower = label.toLowerCase();
    if (!labelLower || JUNK_LABELS.has(labelLower)) {
      // Skip obvious non-system shapes (page, legend, generic labels).
      continue;
    }

    const kind =
      shapeLibIdx !== undefined ? cleanLabel(row[shapeLibIdx]) || null : null;
    const pageId =
      pageIdx !== undefined ? cleanLabel(row[pageIdx]) || null : null;

    const existing = nodesById.get(id);
    if (existing) {
      // Prefer the row with a "better" label (longer, non-empty).
      if (label.length > (existing.label?.length ?? 0)) {
        nodesById.set(id, {
          ...existing,
          label,
          kind: kind ?? existing.kind,
          pageId: pageId ?? existing.pageId,
          raw: record,
        });
      }
    } else {
      nodesById.set(id, {
        id,
        label,
        kind,
        pageId,
        domain: null,
        raw: record,
      });
    }
  }

  const nodes = Array.from(nodesById.values());

  return {
    nodes,
    edges,
    rawRows,
  };
}

/**
 * Compat helpers – if existing code imports a different name,
 * we funnel everything through parseLucidCsv.
 */
export function parseLucidExport(csvText: string): LucidParseResult {
  return parseLucidCsv(csvText);
}

export async function ingestLucidCsv(csvText: string): Promise<LucidParseResult> {
  return parseLucidCsv(csvText);
}
