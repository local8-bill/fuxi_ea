// Auto-generated by Fuxi parser upgrade script.
// Robust Lucid CSV ingestion for real-world Lucidchart exports.

export interface LucidNode {
  id: string;
  label: string;
  kind?: string | null;
  pageId?: string | null;
  domain?: string | null;
  raw?: Record<string, string>;
}

export interface LucidEdge {
  id: string;
  sourceId: string;
  targetId: string;
  label?: string | null;
  raw?: Record<string, string>;
}

export interface LucidParseResult {
  nodes: LucidNode[];
  edges: LucidEdge[];
  rawRows?: Record<string, string>[];
}

// Very small CSV parser, supports quotes, commas, CRLF
function parseCsv(text: string): string[][] {
  const rows: string[][] = [];
  let current: string[] = [];
  let field = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    const next = text[i + 1];

    if (inQuotes) {
      if (ch === '"' && next === '"') {
        field += '"';
        i++;
        continue;
      }
      if (ch === '"') {
        inQuotes = false;
        continue;
      }
      field += ch;
      continue;
    }

    if (ch === '"') {
      inQuotes = true;
      continue;
    }
    if (ch === ",") {
      current.push(field);
      field = "";
      continue;
    }
    if (ch === "\n" || ch === "\r") {
      if (field || current.length) {
        current.push(field);
        rows.push(current);
      }
      current = [];
      field = "";
      if (ch === "\r" && next === "\n") i++;
      continue;
    }

    field += ch;
  }

  if (field || current.length) {
    current.push(field);
    rows.push(current);
  }

  return rows;
}

const JUNK_LABELS = new Set(
  [
    "document",
    "page",
    "new",
    "existing",
    "modified",
    "retire",
    "future",
    "legend",
    "systems / applications",
  ].map((x) => x.toLowerCase()),
);

function clean(s: any): string {
  if (!s) return "";
  return String(s).trim().replace(/^["']|["']$/g, "");
}

export function parseLucidCsv(csvText: string): LucidParseResult {
  const rows = parseCsv(csvText);
  if (rows.length === 0) return { nodes: [], edges: [] };

  const header = rows[0];
  const index: Record<string, number> = {};
  header.forEach((h, i) => (index[h.toLowerCase()] = i));

  const nodes = new Map<string, any>();
  const edges: LucidEdge[] = [];
  const rawRows: Record<string, string>[] = [];

  for (let r = 1; r < rows.length; r++) {
    const row = rows[r];
    if (!row || !row.length) continue;

    const rec: Record<string, string> = {};
    header.forEach((h, i) => (rec[h] = row[i] ?? ""));
    rawRows.push(rec);

    const id = clean(row[index["id"]] ?? "");
    if (!id) continue;

    const src = clean(row[index["line source"]] ?? "");
    const dst = clean(row[index["line destination"]] ?? "");

    // Edge
    if (src || dst) {
      if (src && dst) {
        edges.push({
          id,
          sourceId: src,
          targetId: dst,
          label: clean(row[index["text area 1"]] ?? ""),
          raw: rec,
        });
      }
      continue;
    }

    // Node
    const txt1 = clean(row[index["text area 1"]] ?? "");
    const txt2 = clean(row[index["text area 2"]] ?? "");
    const name = clean(row[index["name"]] ?? "");

    const label = txt1 || txt2 || name;
    if (!label || JUNK_LABELS.has(label.toLowerCase())) continue;

    nodes.set(id, {
      id,
      label,
      raw: rec,
    });
  }

  return {
    nodes: Array.from(nodes.values()),
    edges,
    rawRows,
  };
}

// Compat exports for older imports
export const parseLucidExport = parseLucidCsv;
export const ingestLucidCsv = async (txt: string) => parseLucidCsv(txt);
