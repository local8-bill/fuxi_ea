import { NextRequest, NextResponse } from "next/server";
import OpenAI from "openai";

export const runtime = "nodejs";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface TruthCandidate {
  norm: string;
  inventoryName: string | null;
  diagramNames: string[];
}

interface TruthRow {
  norm: string;
  recommended: string;
  confidence: number;
  reason?: string;
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json().catch(() => null);

    if (!body || !Array.isArray(body.candidates)) {
      return NextResponse.json(
        { ok: false, error: "Missing or invalid candidates array" },
        { status: 400 },
      );
    }

    const { projectId, candidates } = body as {
      projectId?: string;
      candidates: TruthCandidate[];
    };

    if (!process.env.OPENAI_API_KEY) {
      return NextResponse.json(
        { ok: false, error: "Missing OPENAI_API_KEY" },
        { status: 500 },
      );
    }

    const systemPrompt =
      "You are an enterprise architecture assistant aligning system names " +
      "between inventory spreadsheets and architecture diagrams. " +
      "For each candidate, pick the most canonical system name a CIO would expect. " +
      "Respond ONLY as a JSON object with a top-level 'rows' array. " +
      "No markdown. No commentary. No wrapping text.";

    const userContent = {
      projectId: projectId ?? null,
      instructions:
        "For each candidate, return: norm, recommended, confidence (0-100), reason.",
      candidates,
    };

    // --- OPENAI API v2 JSON MODE ---
    const response = await client.responses.create({
      model: "gpt-5.1-mini",
      input: [
        {
          role: "system",
          content: systemPrompt,
        },
        {
          role: "user",
          content: JSON.stringify(userContent),
        },
      ],
      text: {
        format: "json",   // <-- NEW API FIELD
      },
    });

    // In JSON mode, this resolves to a JSON object directly.
    const json = response.output[0].content[0].json as {
      rows?: TruthRow[];
    };

    if (!json || !Array.isArray(json.rows)) {
      console.error("[TRUTH-PASS] AI JSON missing rows[]", json);
      return NextResponse.json(
        {
          ok: false,
          error: "AI JSON missing rows[]",
        },
        { status: 500 },
      );
    }

    const cleaned: TruthRow[] = json.rows
      .filter((r) => r && typeof r.norm === "string")
      .map((r) => ({
        norm: r.norm,
        recommended: r.recommended ?? r.norm,
        confidence:
          typeof r.confidence === "number"
            ? Math.max(0, Math.min(100, r.confidence))
            : 70,
        reason: r.reason,
      }));

    return NextResponse.json(
      {
        ok: true,
        results: cleaned,
      },
      { status: 200 },
    );
  } catch (err: any) {
    console.error("[TRUTH-PASS] Fatal error", err);
    return NextResponse.json(
      {
        ok: false,
        error: err?.message ?? "Unexpected server error",
      },
      { status: 500 },
    );
  }
}
