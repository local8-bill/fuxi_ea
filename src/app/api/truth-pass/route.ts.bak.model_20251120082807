import { NextRequest, NextResponse } from "next/server";
import OpenAI from "openai";

export const runtime = "nodejs";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

type TruthPassCandidate = {
  norm: string;
  inventoryName: string | null;
  diagramNames: string[];
};

type TruthPassRow = {
  norm: string;
  recommended: string;
  confidence: number;
  reason: string;
};

export async function POST(req: NextRequest) {
  try {
    const body = await req.json().catch(() => null);

    const projectId: string | undefined = body?.projectId;
    const candidates: TruthPassCandidate[] | undefined = body?.candidates;

    if (!Array.isArray(candidates) || candidates.length === 0) {
      return NextResponse.json({
        ok: true,
        projectId: projectId ?? null,
        results: [],
      });
    }

    if (!process.env.OPENAI_API_KEY) {
      console.warn("[TRUTH-PASS] Missing OPENAI_API_KEY");
      return NextResponse.json(
        {
          ok: false,
          error: "AI is not configured on this environment.",
          results: [],
        },
        { status: 503 },
      );
    }

    const prompt = buildPrompt(projectId ?? "unknown", candidates);

    const response = await client.responses.create({
      model: "gpt-5.1-mini",
      input: prompt,
    });

    const firstOutput = response.output?.[0]?.content?.[0];
    const textValue =
      typeof (firstOutput as any)?.text?.value === "string"
        ? (firstOutput as any).text.value
        : typeof (firstOutput as any)?.text === "string"
        ? (firstOutput as any).text
        : "";

    if (!textValue) {
      console.error("[TRUTH-PASS] Empty AI response text");
      return NextResponse.json(
        {
          ok: false,
          error: "AI did not return any text.",
          results: [],
        },
        { status: 502 },
      );
    }

    let parsed: any;
    try {
      parsed = JSON.parse(textValue);
    } catch (err) {
      console.error("[TRUTH-PASS] AI returned non JSON", {
        textSample: textValue.slice(0, 400),
      });
      return NextResponse.json(
        {
          ok: false,
          error: "AI returned non JSON",
          raw: textValue,
          results: [],
        },
        { status: 500 },
      );
    }

    if (!parsed || !Array.isArray(parsed.results)) {
      console.error("[TRUTH-PASS] Parsed JSON missing results array", parsed);
      return NextResponse.json(
        {
          ok: false,
          error: "AI JSON did not have a results array.",
          results: [],
        },
        { status: 500 },
      );
    }

    const rows: TruthPassRow[] = parsed.results
      .map((r: any): TruthPassRow | null => {
        if (
          typeof r?.norm !== "string" ||
          typeof r?.recommended !== "string" ||
          typeof r?.confidence !== "number"
        ) {
          return null;
        }
        return {
          norm: r.norm,
          recommended: r.recommended,
          confidence: r.confidence,
          reason:
            typeof r?.reason === "string"
              ? r.reason
              : "No reason provided by AI.",
        };
      })
      .filter((r: TruthPassRow | null): r is TruthPassRow => r !== null);

    return NextResponse.json({
      ok: true,
      projectId: projectId ?? null,
      results: rows,
    });
  } catch (err: any) {
    console.error("[TRUTH-PASS] Unhandled error", err);
    return NextResponse.json(
      {
        ok: false,
        error: err?.message ?? "Truth pass failed.",
        results: [],
      },
      { status: 500 },
    );
  }
}

function buildPrompt(
  projectId: string,
  candidates: TruthPassCandidate[],
): string {
  const payload = JSON.stringify(
    candidates.map((c) => ({
      norm: c.norm,
      inventoryName: c.inventoryName,
      diagramNames: c.diagramNames,
    })),
  );

  return [
    "You are helping an enterprise architect align system names across two sources:",
    "- Inventory spreadsheet system names.",
    "- Lucid diagram system names.",
    "",
    "You receive a list of candidates. Each candidate has:",
    '- norm: a normalized key (lowercase, simple spacing).',
    "- inventoryName: system label from the inventory, or null.",
    "- diagramNames: list of labels from the diagram that share this norm.",
    "",
    "For each candidate, pick a single recommended canonical name.",
    "Prefer official product names, clear scope, and names that will make sense to non technical readers.",
    "",
    "Return a JSON object with the following shape:",
    "{",
    '  "results": [',
    "    {",
    '      "norm": string,',
    '      "recommended": string,',
    '      "confidence": number,          // between 0 and 100',
    '      "reason": string               // one sentence explanation',
    "    }",
    "  ]",
    "}",
    "",
    "Important rules:",
    "- Respond with JSON only. No extra text before or after.",
    "- Every candidate in the input should have exactly one entry in results.",
    "",
    `Project id for context: ${projectId}`,
    "",
    "Candidates JSON:",
    payload,
  ].join("\n");
}
