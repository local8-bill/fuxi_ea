import { NextRequest, NextResponse } from "next/server";
import path from "node:path";
import fs from "node:fs/promises";
import influenceVectors from "@/data/org_insights/influence_vectors.json";
import decisionAlignment from "@/data/org_insights/decision_alignment.json";
import sentimentHistory from "@/data/org_insights/sentiment_history.json";
import readinessProfiles from "@/data/org_insights/readiness_profiles.json";
import readinessComponents from "@/data/org_insights/readiness_components.json";
import decisionVelocity from "@/data/telemetry/decision_velocity.json";
import sequencerProgress from "@/data/sequencer_progress.json";
import aleLearningState from "@/data/ale/learning_state.json";

const DEFAULT_REPORT_TYPE = "org_alignment";

type ReportType = "org_alignment" | "org_readiness";

type BaseReport = {
  type: ReportType;
  metadata: { title: string; generated: string; organization: string };
  markdown: string;
};

type AlignmentReport = BaseReport & {
  summary: string;
  stakeholders: any[];
  decisions: any[];
  sentimentSummary: string;
  recommendations: string[];
  metrics: { consensus_score: number; polarization_index: number; dominant_strategy: string };
  sources: Record<string, unknown>;
};

type ReadinessReport = BaseReport & {
  summary: string;
  categories: Array<{ name: string; readiness: number; risk: string; notes: string }>;
  readinessScore: number;
  confidence: number;
  stage: string;
  deltaHistory: Array<{ date: string; score: number }>;
  recommendations: string[];
  metrics: { capability: number; organizational: number; behavioral: number };
  sources: Record<string, unknown>;
};

function formatPercent(value: number, digits = 0) {
  return `${(value * 100).toFixed(digits)}%`;
}

function buildAlignmentMarkdown(report: AlignmentReport) {
  const lines: string[] = [];
  lines.push(`# ${report.metadata.title}`);
  lines.push("", `Generated: ${report.metadata.generated}`, `Organization: ${report.metadata.organization}`);
  lines.push(
    `Consensus Score: ${report.metrics.consensus_score} | Polarization Index: ${report.metrics.polarization_index} | Dominant Strategy: ${report.metrics.dominant_strategy}`,
  );
  lines.push("", "## Alignment Summary", report.summary);
  lines.push("", "### Stakeholder Consensus");
  lines.push("| Stakeholder | Alignment | Influence | Bias |", "|-----------|-----------|-----------|------|");
  report.stakeholders.forEach((stakeholder) => {
    lines.push(`| ${stakeholder.name} | ${stakeholder.alignment.toFixed(2)} | ${stakeholder.influence.toFixed(2)} | ${stakeholder.bias} |`);
  });
  lines.push("", "### Decision Influence Summary");
  report.decisions.forEach((decision) => {
    lines.push(
      `- **${decision.title}** – alignment ${decision.alignment.toFixed(2)}, ROI ${formatPercent(decision.roi)}, TCC ${formatPercent(decision.tcc)}, supported by ${decision.supporters.join(", ")}`,
    );
  });
  lines.push("", "### Sentiment & Readiness", report.sentimentSummary);
  lines.push("", "### Recommendations");
  report.recommendations.forEach((rec, idx) => lines.push(`${idx + 1}. ${rec}`));
  lines.push("", "---", "Generated by Fuxi Intelligence Engine (ALE + EAgent)");
  return lines.join("\n");
}

function buildReadinessMarkdown(report: ReadinessReport) {
  const lines: string[] = [];
  lines.push(`# ${report.metadata.title}`);
  lines.push("", `Generated: ${report.metadata.generated}`, `Organization: ${report.metadata.organization}`);
  lines.push(`Readiness Score: ${formatPercent(report.readinessScore, 0)} | Confidence: ${formatPercent(report.confidence)} | Stage: ${report.stage}`);
  lines.push("", "## Readiness Summary", report.summary);
  lines.push("", "### Category Breakdown");
  lines.push("| Category | Readiness | Risk | Notes |", "|----------|-----------|------|-------|");
  report.categories.forEach((category) => {
    lines.push(`| ${category.name} | ${formatPercent(category.readiness)} | ${category.risk} | ${category.notes} |`);
  });
  lines.push("", "### Recommendations");
  report.recommendations.forEach((rec, idx) => lines.push(`${idx + 1}. ${rec}`));
  lines.push("", "### Readiness Delta", "Date | Score", "-----|------");
  report.deltaHistory.forEach((entry) => lines.push(`${entry.date} | ${formatPercent(entry.score)}`));
  lines.push("", "---", "Generated by Fuxi Intelligence Engine (ALE + EAgent)");
  return lines.join("\n");
}

function buildOrgAlignmentReport(): AlignmentReport {
  const metadata = {
    title: "Organizational Alignment Index – OMS Transformation",
    generated: new Date().toISOString(),
    organization: (decisionAlignment as any).organization ?? "Deckers",
  };

  const stakeholderAvg =
    (influenceVectors as any[]).reduce((sum: number, entry: any) => sum + Number(entry.alignment ?? 0), 0) / Math.max(1, (influenceVectors as any[]).length);
  const supportLeaders = (influenceVectors as any[])
    .slice()
    .sort((a: any, b: any) => (b.alignment ?? 0) - (a.alignment ?? 0))
    .slice(0, 3)
    .map((entry: any) => entry.name);

  const summary = `Stakeholder alignment averages ${(stakeholderAvg * 100).toFixed(0)}% with ${supportLeaders.join(", ")} driving consensus. Finance and Engineering remain the primary friction points.`;

  const sentimentSummary = (sentimentHistory as any[])
    .slice(-2)
    .map((entry: any) => `${entry.tone}: ${entry.summary}`)
    .join(" ");

  const recommendations = [
    "Maintain NA-first rollout but expose ROI telemetry for Finance at each gate.",
    "Pair Engineering + Integration leads on throwaway work to reduce skepticism.",
    "EAgent should alert when polarization jumps above 0.30 during sequencer moves.",
  ];

  return {
    type: "org_alignment",
    metadata,
    summary,
    stakeholders: influenceVectors as any[],
    decisions: ((decisionAlignment as any).decisions ?? []) as any[],
    sentimentSummary,
    recommendations,
    metrics: {
      consensus_score: (decisionAlignment as any).consensus_score,
      polarization_index: (decisionAlignment as any).polarization_index,
      dominant_strategy: (decisionAlignment as any).dominant_strategy,
    },
    markdown: "",
    sources: {
      influence: (influenceVectors as any[]).length,
      decisions: ((decisionAlignment as any).decisions ?? []).length,
      sentiments: (sentimentHistory as any[]).length,
      readiness: (readinessProfiles as any).readiness_stage,
    },
  };
}

function buildOrgReadinessReport(): ReadinessReport {
  const metadata = {
    title: "Organizational Readiness Index – OMS Transformation",
    generated: new Date().toISOString(),
    organization: (readinessComponents as any).organization ?? "Deckers",
  };

  const categories = (readinessComponents as any).categories ?? [];
  const avgReadiness = categories.reduce((sum: number, item: any) => sum + Number(item.readiness ?? 0), 0) / Math.max(1, categories.length);
  const learningState = aleLearningState as any;
  const readinessScore = Number(learningState.org_readiness_score ?? avgReadiness);
  const summary = `Readiness averages ${formatPercent(readinessScore)} with strongest capability in ${categories[0]?.name ?? "Integration"}. Change enablement remains the primary blocker.`;

  return {
    type: "org_readiness",
    metadata,
    summary,
    categories,
    readinessScore,
    confidence: Number((readinessComponents as any).confidence ?? 0.85),
    stage: (readinessComponents as any).stage ?? "Early Adaptive",
    deltaHistory: (learningState.delta_history ?? []) as Array<{ date: string; score: number }>,
    recommendations: (readinessComponents as any).recommendations ?? [],
    metrics: {
      capability: Number(learningState.capability_factor ?? avgReadiness),
      organizational: Number(learningState.organizational_factor ?? avgReadiness),
      behavioral: Number(learningState.behavioral_factor ?? avgReadiness),
    },
    markdown: "",
    sources: {
      decision_velocity: decisionVelocity,
      sequencer_progress: sequencerProgress,
      ale_learning: learningState,
    },
  };
}

async function attachMarkdown(report: AlignmentReport | ReadinessReport) {
  const filename = report.type === "org_alignment" ? "org_alignment_oms.md" : "org_readiness_index.md";
  const fallback = report.type === "org_alignment" ? buildAlignmentMarkdown : buildReadinessMarkdown;
  const reportPath = path.join(process.cwd(), "intelligence", "reports", filename);
  try {
    const existing = await fs.readFile(reportPath, "utf8");
    report.markdown = existing;
  } catch {
    report.markdown = fallback(report as any);
  }
  return report;
}

export async function GET(request: NextRequest) {
  const url = new URL(request.url);
  const type = (url.searchParams.get("type") ?? DEFAULT_REPORT_TYPE) as ReportType;

  let report: AlignmentReport | ReadinessReport;
  switch (type) {
    case "org_readiness":
      report = buildOrgReadinessReport();
      break;
    case "org_alignment":
    default:
      report = buildOrgAlignmentReport();
  }

  report = await attachMarkdown(report);

  const format = url.searchParams.get("format");
  if (format === "markdown") {
    return new Response(report.markdown, {
      headers: {
        "Content-Type": "text/markdown; charset=utf-8",
        "Cache-Control": "no-store",
      },
    });
  }

  return NextResponse.json(report, { headers: { "Cache-Control": "no-store" } });
}
