"use client";

import { useEffect, useState } from "react";
import { WorkspaceHeader } from "@/components/layout/WorkspaceHeader";
import { FileUploadPanel } from "@/components/panels/FileUploadPanel";
import { MetricCard } from "@/components/ui/MetricCard";
import { Card } from "@/components/ui/Card";
import {
  uploadLucidCsv,
  fetchDigitalEnterpriseStats,
} from "@/lib/api/digitalEnterprise";
import { parseInventoryCsv } from "@/domain/services/inventoryIngestion";
import { normalizeSystemName } from "@/domain/services/systemNormalization";

interface DigitalEnterpriseStats {
  systemsFuture: number;
  integrationsFuture: number;
  domainsDetected?: number;
}

interface Props {
  projectId: string;
}

interface InventoryStatsLocal {
  projectId: string;
  rowCount: number;
  uniqueSystems: number;
}

interface DiagramSystem {
  id: string;
  name: string;
  normalizedName: string;
  integrationCount: number;
}

interface DiffStats {
  inventoryCount: number;
  diagramCount: number;
  overlapCount: number;
  inventoryOnlyNorms: string[];
  diagramOnly: DiagramSystem[];
  overlapSystems: DiagramSystem[];
}

type TruthDecision = "keep" | "remove" | "ignore";

interface TruthRow {
  norm: string;
  inventoryName: string | null;
  diagramNames: string[];
  recommended: string;
  confidencePct: number;
  rationale: string;
}

function formatNumber(n: number | undefined | null): string {
  if (n == null || Number.isNaN(n)) return "0";
  return n.toLocaleString();
}

// Small, deterministic explanation if AI is unavailable (fallback)
function localExplainTruthRow(row: TruthRow): string {
  const { inventoryName, diagramNames } = row;
  const hasInventory = !!inventoryName;
  const hasDiagram = diagramNames.length > 0;

  if (hasInventory && hasDiagram) {
    const inventory = inventoryName!.trim().toLowerCase();
    const diagram = diagramNames[0].trim().toLowerCase();
    if (inventory === diagram) {
      return "Inventory and diagram already use the same name.";
    }
    return "Names differ slightly; using the diagram label as the canonical name.";
  }

  if (hasInventory && !hasDiagram) {
    return "Only appears in your inventory spreadsheet.";
  }

  if (!hasInventory && hasDiagram) {
    return "Only appears in the Lucid diagram.";
  }

  return "Heuristic suggestion based on available names.";
}

export function TechStackClient({ projectId }: Props) {
  // Inventory / artifacts
  const [artifactCount, setArtifactCount] = useState<number>(0);
  const [inventoryRows, setInventoryRows] = useState<number>(0);
  const [normalizedApps, setNormalizedApps] = useState<number>(0);
  const [invStats, setInvStats] = useState<InventoryStatsLocal | null>(null);
  const [uploadingInv, setUploadingInv] = useState<boolean>(false);
  const [invError, setInvError] = useState<string | null>(null);

  // Digital Enterprise
  const [deStats, setDeStats] = useState<DigitalEnterpriseStats | null>(null);
  const [loadingDE, setLoadingDE] = useState<boolean>(true);
  const [uploadingLucid, setUploadingLucid] = useState<boolean>(false);
  const [deError, setDeError] = useState<string | null>(null);

  // Diff plumbing (engine behind Truth Pass)
  const [inventorySystemsNorm, setInventorySystemsNorm] = useState<string[]>([]);
  const [inventoryDisplayByNorm, setInventoryDisplayByNorm] = useState<
    Record<string, string>
  >({});
  const [diagramSystems, setDiagramSystems] = useState<DiagramSystem[]>([]);
  const [diffStats, setDiffStats] = useState<DiffStats | null>(null);
  const [diffError, setDiffError] = useState<string | null>(null);

  // Truth-pass state (AI results + local decisions)
  const [truthRows, setTruthRows] = useState<TruthRow[]>([]);
  const [truthLoading, setTruthLoading] = useState<boolean>(false);
  const [truthError, setTruthError] = useState<string | null>(null);
  const [truthDecisions, setTruthDecisions] = useState<
    Record<string, TruthDecision>
  >({});

  // ---- Load DE stats + diagram systems on mount / project change ----
  useEffect(() => {
    let cancelled = false;

    async function loadDEAndSystems() {
      setLoadingDE(true);
      setDeError(null);
      setDiffError(null);
      setTruthError(null);

      try {
        const stats = await fetchDigitalEnterpriseStats(projectId);
        if (cancelled) return;

        if (stats) {
          setDeStats(stats);
        } else {
          setDeStats(null);
        }
      } catch (err: any) {
        console.error("[TECH-STACK] Error loading digital enterprise stats", err);
        if (!cancelled) {
          setDeError("Failed to load digital enterprise preview.");
          setDeStats(null);
        }
      } finally {
        if (!cancelled) {
          setLoadingDE(false);
        }
      }

      // Load diagram systems for diff / truth pass
      try {
        const res = await fetch(
          `/api/digital-enterprise/systems?project=${encodeURIComponent(
            projectId,
          )}`,
          { cache: "no-store" },
        );
        if (!res.ok) {
          const text = await res.text().catch(() => "");
          console.error(
            "[TECH-STACK] Failed to load diagram systems for diff",
            res.status,
            text,
          );
          if (!cancelled) {
            setDiffError("Failed to load diagram systems for diff view.");
            setDiagramSystems([]);
          }
          return;
        }
        const json = await res.json();
        if (cancelled) return;

        if (json && Array.isArray(json.systems)) {
          const systems: DiagramSystem[] = json.systems.map((s: any) => ({
            id: String(s.id ?? s.name ?? s.normalizedName ?? "unknown"),
            name: String(s.name ?? "Unknown"),
            normalizedName: String(
              s.normalizedName ?? normalizeSystemName(s.name),
            ),
            integrationCount: Number(s.integrationCount ?? 0),
          }));
          setDiagramSystems(systems);
        } else {
          setDiagramSystems([]);
        }
      } catch (err: any) {
        console.error("[TECH-STACK] Error fetching diagram systems for diff", err);
        if (!cancelled) {
          setDiffError("Failed to load diagram systems for diff view.");
          setDiagramSystems([]);
        }
      }
    }

    loadDEAndSystems();

    return () => {
      cancelled = true;
    };
  }, [projectId]);

  // ---- Compute diff whenever inventory systems or diagram systems change ----
  useEffect(() => {
    const invNormSet = new Set(
      (inventorySystemsNorm ?? []).filter((n) => n && n.trim().length > 0),
    );
    const diagNormSet = new Set(
      (diagramSystems ?? [])
        .map((s) => s.normalizedName)
        .filter((n) => n && n.trim().length > 0),
    );

    if (invNormSet.size === 0 && diagNormSet.size === 0) {
      setDiffStats(null);
      setTruthRows([]);
      return;
    }

    const inventoryOnlyNorms: string[] = [];
    const overlapNorms = new Set<string>();

    for (const norm of invNormSet) {
      if (diagNormSet.has(norm)) {
        overlapNorms.add(norm);
      } else {
        inventoryOnlyNorms.push(norm);
      }
    }

    const diagramOnly: DiagramSystem[] = [];
    const overlapSystems: DiagramSystem[] = [];

    for (const s of diagramSystems) {
      const norm = s.normalizedName;
      if (!norm) continue;
      if (invNormSet.has(norm)) {
        overlapSystems.push(s);
      } else {
        diagramOnly.push(s);
      }
    }

    const diff: DiffStats = {
      inventoryCount: invNormSet.size,
      diagramCount: diagNormSet.size,
      overlapCount: overlapNorms.size,
      inventoryOnlyNorms,
      diagramOnly,
      overlapSystems,
    };

    setDiffStats(diff);
  }, [inventorySystemsNorm, diagramSystems]);

  // ---- Call AI Truth Pass whenever diff changes ----
  useEffect(() => {
    async function runTruthPass() {
      if (!diffStats) {
        setTruthRows([]);
        setTruthError(null);
        return;
      }

      const invNorms = new Set(
        (inventorySystemsNorm ?? []).filter((n) => n && n.trim().length > 0),
      );
      const diagNorms = new Set(
        (diagramSystems ?? [])
          .map((s) => s.normalizedName)
          .filter((n) => n && n.trim().length > 0),
      );

      const allNorms = new Set<string>();
      invNorms.forEach((n) => allNorms.add(n));
      diagNorms.forEach((n) => allNorms.add(n));

      if (allNorms.size === 0) {
        setTruthRows([]);
        setTruthError(null);
        return;
      }

      const candidates = Array.from(allNorms).map((norm) => {
        const inventoryName = inventoryDisplayByNorm[norm] ?? null;
        const diagramNames = diagramSystems
          .filter((s) => s.normalizedName === norm)
          .map((s) => s.name)
          .filter((name, idx, arr) => name && arr.indexOf(name) === idx);

        return {
          norm,
          inventoryName,
          diagramNames,
        };
      });

      setTruthLoading(true);
      setTruthError(null);

      try {
        const res = await fetch("/api/truth-pass", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            projectId,
            candidates,
          }),
        });

        if (!res.ok) {
          const text = await res.text().catch(() => "");
          console.error("[TRUTH-PASS] API error", res.status, text);
          setTruthError(
            "AI suggestions are temporarily unavailable. Showing nothing for now.",
          );
          setTruthRows([]);
          return;
        }

        const json = await res.json();
        if (!json || !Array.isArray(json.rows)) {
        console.error("[TRUTH-PASS] Unexpected response shape", json);
        setTruthError(
        "AI suggestions returned an unexpected format. Showing nothing for now.",
      );
      return;
      }
const newRows = json.rows;

        const rows: TruthRow[] = json.rows.map((r: any) => ({
          norm: String(r.norm ?? ""),
          inventoryName:
            r.inventoryName === null || r.inventoryName === undefined
              ? null
              : String(r.inventoryName),
          diagramNames: Array.isArray(r.diagramNames)
            ? r.diagramNames.map((d: any) => String(d))
            : [],
          recommended: String(r.recommended ?? r.norm ?? ""),
          confidencePct: Number(r.confidencePct ?? 70),
          rationale: String(
            r.rationale ??
              localExplainTruthRow({
                norm: String(r.norm ?? ""),
                inventoryName:
                  r.inventoryName === null || r.inventoryName === undefined
                    ? null
                    : String(r.inventoryName),
                diagramNames: Array.isArray(r.diagramNames)
                  ? r.diagramNames.map((d: any) => String(d))
                  : [],
                recommended: String(r.recommended ?? r.norm ?? ""),
                confidencePct: Number(r.confidencePct ?? 70),
                rationale: "",
              }),
          ),
        }));

        // Simple sort: high confidence first
        rows.sort((a, b) => {
          if (b.confidencePct !== a.confidencePct) {
            return b.confidencePct - a.confidencePct;
          }
          return a.recommended.localeCompare(b.recommended);
        });

        setTruthRows(rows.slice(0, 50));
      } catch (err: any) {
        console.error("[TRUTH-PASS] Failed to fetch AI suggestions", err);
        setTruthError(
          "AI suggestions failed to load. Check server logs or OpenAI configuration.",
        );
        setTruthRows([]);
      } finally {
        setTruthLoading(false);
      }
    }

    runTruthPass();
  }, [
    projectId,
    diffStats,
    inventorySystemsNorm,
    inventoryDisplayByNorm,
    diagramSystems,
  ]);

  // Placeholder for future persistence
  function handleTruthDecision(id: string, decision: TruthDecision) {
    setTruthDecisions((prev) => ({
      ...prev,
      [id]: decision,
    }));
  }

  // ---- Inventory upload ----
  async function handleInventoryUpload(file: File) {
    setUploadingInv(true);
    setInvError(null);

    try {
      console.log("[TECH-STACK] Inventory upload started", {
        projectId,
        fileName: file.name,
      });

      if (!file.name.toLowerCase().endsWith(".csv")) {
        throw new Error(
          "Unsupported file type. Please export your Excel inventory as CSV and upload the .csv file.",
        );
      }

      const text = await file.text();
      const parsed = parseInventoryCsv(text);

      const stats: InventoryStatsLocal = {
        projectId,
        rowCount: parsed.rows.length,
        uniqueSystems: parsed.uniqueSystems,
      };

      setInvStats(stats);
      setInventoryRows(stats.rowCount);
      setNormalizedApps(stats.uniqueSystems);

      setArtifactCount((prev) =>
        stats.rowCount > 0 ? Math.max(prev, 1) : prev,
      );

      const normSet = new Set<string>();
      const displayMap: Record<string, string> = {};
      for (const item of parsed.rows) {
        const displayName = item.systemName || "";
        const norm = normalizeSystemName(displayName);
        if (!norm) continue;
        normSet.add(norm);
        if (!displayMap[norm] && displayName) {
          displayMap[norm] = displayName;
        }
      }
      setInventorySystemsNorm(Array.from(normSet));
      setInventoryDisplayByNorm(displayMap);

      console.log("[TECH-STACK] Inventory parsed locally", {
        rowCount: stats.rowCount,
        uniqueSystems: stats.uniqueSystems,
      });
    } catch (err: any) {
      console.error("[TECH-STACK] Inventory upload failed (client parse)", err);
      setInvError(err?.message ?? "Inventory upload failed.");
      setInventorySystemsNorm([]);
      setInventoryDisplayByNorm({});
    } finally {
      setUploadingInv(false);
    }
  }

  // ---- Lucid upload ----
  async function handleLucidUpload(file: File) {
    setUploadingLucid(true);
    setDeError(null);
    setDiffError(null);
    setTruthError(null);

    try {
      const resp = await uploadLucidCsv(projectId, file);
      console.log("[TECH-STACK] Lucid upload success", resp);

      const stats = await fetchDigitalEnterpriseStats(projectId);
      if (stats) {
        setDeStats(stats);
      }

      try {
        const res = await fetch(
          `/api/digital-enterprise/systems?project=${encodeURIComponent(
            projectId,
          )}`,
          { cache: "no-store" },
        );
        if (res.ok) {
          const json = await res.json();
          if (json && Array.isArray(json.systems)) {
            const systems: DiagramSystem[] = json.systems.map((s: any) => ({
              id: String(s.id ?? s.name ?? s.normalizedName ?? "unknown"),
              name: String(s.name ?? "Unknown"),
              normalizedName: String(
                s.normalizedName ?? normalizeSystemName(s.name),
              ),
              integrationCount: Number(s.integrationCount ?? 0),
            }));
            setDiagramSystems(systems);
          } else {
            setDiagramSystems([]);
          }
        } else {
          const text = await res.text().catch(() => "");
          console.error(
            "[TECH-STACK] Failed to refresh diagram systems after Lucid upload",
            res.status,
            text,
          );
        }
      } catch (err: any) {
        console.error(
          "[TECH-STACK] Error refreshing diagram systems after Lucid upload",
          err,
        );
      }

      setArtifactCount((prev) => Math.max(prev, 1));
    } catch (err: any) {
      console.error("[TECH-STACK] Lucid upload failed", err);
      setDeError(err?.message ?? "Lucid upload failed.");
    } finally {
      setUploadingLucid(false);
    }
  }

  const hasDE =
    !!deStats &&
    ((deStats.systemsFuture ?? 0) > 0 ||
      (deStats.integrationsFuture ?? 0) > 0);

  // ---- Render ----
  return (
    <div className="px-8 py-10 max-w-6xl mx-auto">
      <WorkspaceHeader
        statusLabel="STATUS"
        title="Tech Stack Workspace"
        description="Upload inventories, diagrams, and Lucid exports to understand your applications, integrations, and dependencies."
      />

      {/* Inputs description */}
      <Card className="mb-4">
        <p className="text-[0.65rem] tracking-[0.25em] text-gray-500 mb-1 uppercase">
          INPUTS
        </p>
        <p className="text-xs text-gray-500">
          Upload artifacts to build a live view of your digital enterprise for project{" "}
          <span className="font-medium">{projectId}</span>.
        </p>
      </Card>

      {/* Upload panels */}
      <FileUploadPanel
        title="UPLOAD INVENTORY SPREADSHEET"
        helper="Export your technology inventory from Excel as CSV and upload it here. We'll parse systems and normalize them for comparison."
        label={uploadingInv ? "Uploading..." : "Upload Inventory CSV"}
        onFileSelected={handleInventoryUpload}
        className="mb-4"
      />

      <FileUploadPanel
        title="UPLOAD LUCID CSV"
        helper="Upload a Lucid CSV export of your architecture diagram. We'll infer systems and integrations automatically and update the Digital Enterprise metrics."
        label={uploadingLucid ? "Uploading..." : "Upload Lucid CSV"}
        onFileSelected={handleLucidUpload}
      />

      {/* Inventory / artifact metrics */}
      <div className="mb-8 grid grid-cols-1 sm:grid-cols-3 gap-4 mt-6">
        <MetricCard
          label="ARTIFACTS"
          value={formatNumber(artifactCount)}
          description="Inventory and diagram files in this project."
        />
        <MetricCard
          label="INVENTORY ROWS"
          value={formatNumber(inventoryRows)}
          description="Application rows ingested from spreadsheets."
        />
        <MetricCard
          label="NORMALIZED APPS"
          value={formatNumber(normalizedApps)}
          description="Systems clustered into canonical applications from inventory."
        />
      </div>

      {invError && (
        <div className="mb-4 text-xs text-red-500">{invError}</div>
      )}

      {/* Digital Enterprise preview */}
      <Card className="mb-8">
        <p className="text-[0.65rem] tracking-[0.25em] text-gray-500 mb-1 uppercase">
          DIGITAL ENTERPRISE PREVIEW
        </p>
        <p className="text-xs text-gray-500 mb-4">
          Derived from your Lucid architecture diagram. Systems and integrations
          here represent the structural view of your ecosystem.
        </p>
        {loadingDE && (
          <div className="text-sm text-gray-500">
            Loading Digital Enterprise preview...
          </div>
        )}
        {!loadingDE && deError && (
          <div className="text-sm text-red-500">{deError}</div>
        )}
        {!loadingDE && !deError && hasDE && deStats && (
          <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
            <MetricCard
              label="SYSTEMS"
              value={formatNumber(deStats.systemsFuture)}
              description="Unique labeled systems in this diagram."
            />
            <MetricCard
              label="INTEGRATIONS"
              value={formatNumber(deStats.integrationsFuture)}
              description="System-to-system connections from Lucid connector lines."
            />
            <MetricCard
              label="DOMAINS DETECTED"
              value={formatNumber(deStats.domainsDetected ?? 0)}
              description="Domain clustering will be introduced in a later iteration."
            />
          </div>
        )}
        {!loadingDE && !deError && !hasDE && (
          <div className="text-sm text-gray-500">
            No Digital Enterprise metrics yet. Upload a Lucid CSV to populate this
            preview.
          </div>
        )}
      </Card>

      {/* TRUTH PASS – AI suggestions made explicit */}
      <Card className="mt-6">
        <div className="flex items-center justify-between mb-1">
          <p className="text-[0.65rem] tracking-[0.25em] text-gray-500 uppercase">
            TRUTH PASS · AI SUGGESTIONS
          </p>
          <span className="inline-flex items-center rounded-full bg-slate-900 px-2 py-0.5 text-[0.65rem] font-medium text-white">
            AI Powered
          </span>
        </div>
        <p className="text-xs text-gray-500 mb-4">
          Fuxi compares your inventory and Lucid diagram for project {projectId} and
          suggests a canonical system name with a confidence rating. Use this as a
          sanity check before you trust the diff.
        </p>

        {truthLoading && (
          <div className="mb-3 text-xs text-slate-500">
            Running AI Truth Pass on your systems...
          </div>
        )}
        {truthError && (
          <div className="mb-3 text-xs text-red-500">{truthError}</div>
        )}

        <div className="rounded-2xl border border-gray-200 bg-white overflow-hidden">
          <div className="grid grid-cols-3 gap-4 px-4 py-2 text-[0.65rem] tracking-[0.22em] text-gray-500 uppercase bg-slate-50">
            <span>Inventory</span>
            <span>Diagram</span>
            <span className="text-right">Action</span>
          </div>

          <div className="divide-y divide-gray-100">
            {truthRows.length === 0 && !truthLoading ? (
              <div className="px-4 py-3 text-xs text-slate-500">
                Upload both an inventory CSV and a Lucid CSV for this project to see
                AI Truth Pass suggestions.
              </div>
            ) : (
              truthRows.map((row) => {
                const {
                  norm,
                  inventoryName,
                  diagramNames,
                  recommended,
                  confidencePct,
                  rationale,
                } = row;

                const hasInventory = !!inventoryName;
                const hasDiagram = diagramNames.length > 0;

                const inventoryMatches =
                  hasInventory &&
                  inventoryName!.trim().toLowerCase() ===
                    recommended.trim().toLowerCase();

                const diagramMain = hasDiagram ? diagramNames[0] : "";
                const diagramRest = hasDiagram ? diagramNames.slice(1) : [];

                const diagramMatches =
                  hasDiagram &&
                  diagramMain.trim().toLowerCase() ===
                    recommended.trim().toLowerCase();

                const inventoryClass = inventoryMatches
                  ? "font-semibold text-slate-900"
                  : hasInventory
                  ? "text-slate-600"
                  : "text-slate-400 italic";

                const diagramMainClass = diagramMatches
                  ? "font-semibold text-slate-900"
                  : hasDiagram
                  ? "text-slate-600"
                  : "text-slate-400 italic";

                return (
                  <div
                    key={norm}
                    className="grid grid-cols-3 gap-4 px-4 py-3 text-sm items-center"
                  >
                    {/* Inventory name */}
                    <div className="flex flex-col">
                      <span className={inventoryClass}>
                        {hasInventory ? inventoryName : "Not in inventory"}
                      </span>
                    </div>

                    {/* Diagram names + Recommended pill */}
                    <div className="flex flex-col">
                      <span className={diagramMainClass}>
                        {hasDiagram ? diagramMain : "Not in diagram"}
                      </span>
                      {diagramRest.length > 0 && (
                        <span className="mt-0.5 text-[0.65rem] text-slate-400">
                          Also: {diagramRest.join(", ")}
                        </span>
                      )}
                      {(inventoryMatches || diagramMatches) && (
                        <span className="mt-1 inline-flex items-center rounded-full bg-emerald-50 px-2 py-0.5 text-[0.65rem] font-medium text-emerald-700">
                          Recommended
                        </span>
                      )}
                    </div>

                    {/* Confidence + actions + rationale */}
                    <div className="flex flex-col items-end gap-1">
                      <div className="flex items-center justify-end gap-3">
                        <span className="inline-flex items-center rounded-full bg-slate-900 px-3 py-1 text-[0.7rem] font-medium text-white">
                          {confidencePct}%
                        </span>
                        <button
                          className="px-2.5 py-1 rounded-md bg-gray-100 text-[0.7rem] font-medium text-gray-700 hover:bg-gray-200"
                          type="button"
                          onClick={() => handleTruthDecision(norm, "keep")}
                        >
                          Keep
                        </button>
                        <button
                          className="px-2.5 py-1 rounded-md bg-gray-100 text-[0.7rem] font-medium text-gray-700 hover:bg-gray-200"
                          type="button"
                          onClick={() => handleTruthDecision(norm, "ignore")}
                        >
                          Edit
                        </button>
                        <button
                          className="px-2.5 py-1 rounded-md bg-gray-100 text-[0.7rem] font-medium text-red-600 hover:bg-gray-200"
                          type="button"
                          onClick={() => handleTruthDecision(norm, "remove")}
                        >
                          Delete
                        </button>
                      </div>
                      <p className="text-[0.65rem] text-slate-400 text-right">
                        AI: {rationale}
                      </p>
                    </div>
                  </div>
                );
              })
            )}
          </div>

          <div className="border-t border-slate-100 bg-slate-50 px-4 py-2 text-[0.7rem] text-slate-500 flex items-center justify-between">
            <span>Preview only — AI suggestions and decisions are not yet saved.</span>
            <span className="text-[0.65rem] uppercase tracking-[0.18em] text-slate-400">
              Powered by AI
            </span>
          </div>
        </div>
      </Card>
    </div>
  );
}
