"use client";

import { useEffect, useState } from "react";
import { WorkspaceHeader } from "@/components/layout/WorkspaceHeader";
import { FileUploadPanel } from "@/components/panels/FileUploadPanel";
import { MetricCard } from "@/components/ui/MetricCard";
import { Card } from "@/components/ui/Card";
import {
  uploadLucidCsv,
  fetchDigitalEnterpriseStats,
} from "@/lib/api/digitalEnterprise";
import { parseInventoryCsv } from "@/domain/services/inventoryIngestion";
import { normalizeSystemName } from "@/domain/services/systemNormalization";

interface DigitalEnterpriseStats {
  systemsFuture: number;
  integrationsFuture: number;
  domainsDetected?: number;
}

interface Props {
  projectId: string;
}

interface InventoryStatsLocal {
  projectId: string;
  rowCount: number;
  uniqueSystems: number;
}

interface DiagramSystem {
  id: string;
  name: string;
  normalizedName: string;
  integrationCount: number;
}

interface DiffStats {
  inventoryCount: number;
  diagramCount: number;
  overlapCount: number;
  inventoryOnlyNorms: string[];
  diagramOnly: DiagramSystem[];
  overlapSystems: DiagramSystem[];
}

type TruthDecision = "keep" | "remove" | "ignore";

interface TruthCandidate {
  id: string;
  source: "inventory" | "diagram";
  displayName: string;
  normalizedName: string;
}

function formatNumber(n: number | undefined | null): string {
  if (n == null || Number.isNaN(n)) return "0";
  return n.toLocaleString();
}

export function TechStackClient({ projectId }: Props) {
  // Inventory / artifacts
  const [artifactCount, setArtifactCount] = useState<number>(0);
  const [inventoryRows, setInventoryRows] = useState<number>(0);
  const [normalizedApps, setNormalizedApps] = useState<number>(0);
  const [invStats, setInvStats] = useState<InventoryStatsLocal | null>(null);
  const [uploadingInv, setUploadingInv] = useState<boolean>(false);
  const [invError, setInvError] = useState<string | null>(null);

  // Digital Enterprise
  const [deStats, setDeStats] = useState<DigitalEnterpriseStats | null>(null);
  const [loadingDE, setLoadingDE] = useState<boolean>(true);
  const [uploadingLucid, setUploadingLucid] = useState<boolean>(false);
  const [deError, setDeError] = useState<string | null>(null);

  // Diff plumbing (engine behind Truth Pass)
  const [inventorySystemsNorm, setInventorySystemsNorm] = useState<string[]>([]);
  const [inventoryDisplayByNorm, setInventoryDisplayByNorm] = useState<
    Record<string, string>
  >({});
  const [diagramSystems, setDiagramSystems] = useState<DiagramSystem[]>([]);
  const [diffStats, setDiffStats] = useState<DiffStats | null>(null);
  const [diffError, setDiffError] = useState<string | null>(null);

  // Truth-pass state (placeholder for future persistence)
  const [truthDecisions, setTruthDecisions] = useState<
    Record<string, TruthDecision>
  >({});

  // ---- Load DE stats + diagram systems on mount / project change ----
  useEffect(() => {
    let cancelled = false;

    async function loadDEAndSystems() {
      setLoadingDE(true);
      setDeError(null);
      setDiffError(null);

      try {
        const stats = await fetchDigitalEnterpriseStats(projectId);
        if (cancelled) return;

        if (stats) {
          setDeStats(stats);
        } else {
          setDeStats(null);
        }
      } catch (err: any) {
        console.error("[TECH-STACK] Error loading digital enterprise stats", err);
        if (!cancelled) {
          setDeError("Failed to load digital enterprise preview.");
          setDeStats(null);
        }
      } finally {
        if (!cancelled) {
          setLoadingDE(false);
        }
      }

      // Load diagram systems for diff / truth pass
      try {
        const res = await fetch(
          `/api/digital-enterprise/systems?project=${encodeURIComponent(
            projectId,
          )}`,
          { cache: "no-store" },
        );
        if (!res.ok) {
          const text = await res.text().catch(() => "");
          console.error(
            "[TECH-STACK] Failed to load diagram systems for diff",
            res.status,
            text,
          );
          if (!cancelled) {
            setDiffError("Failed to load diagram systems for diff view.");
            setDiagramSystems([]);
          }
          return;
        }
        const json = await res.json();
        if (cancelled) return;

        if (json && Array.isArray(json.systems)) {
          const systems: DiagramSystem[] = json.systems.map((s: any) => ({
            id: String(s.id ?? s.name ?? s.normalizedName ?? "unknown"),
            name: String(s.name ?? "Unknown"),
            normalizedName: String(
              s.normalizedName ?? normalizeSystemName(s.name),
            ),
            integrationCount: Number(s.integrationCount ?? 0),
          }));
          setDiagramSystems(systems);
        } else {
          setDiagramSystems([]);
        }
      } catch (err: any) {
        console.error("[TECH-STACK] Error fetching diagram systems for diff", err);
        if (!cancelled) {
          setDiffError("Failed to load diagram systems for diff view.");
          setDiagramSystems([]);
        }
      }
    }

    loadDEAndSystems();

    return () => {
      cancelled = true;
    };
  }, [projectId]);

  // ---- Compute diff whenever inventory systems or diagram systems change ----
  useEffect(() => {
    const invNormSet = new Set(
      (inventorySystemsNorm ?? []).filter((n) => n && n.trim().length > 0),
    );
    const diagNormSet = new Set(
      (diagramSystems ?? [])
        .map((s) => s.normalizedName)
        .filter((n) => n && n.trim().length > 0),
    );

    if (invNormSet.size === 0 && diagNormSet.size === 0) {
      setDiffStats(null);
      return;
    }

    const inventoryOnlyNorms: string[] = [];
    const overlapNorms = new Set<string>();

    for (const norm of invNormSet) {
      if (diagNormSet.has(norm)) {
        overlapNorms.add(norm);
      } else {
        inventoryOnlyNorms.push(norm);
      }
    }

    const diagramOnly: DiagramSystem[] = [];
    const overlapSystems: DiagramSystem[] = [];

    for (const s of diagramSystems) {
      const norm = s.normalizedName;
      if (!norm) continue;
      if (invNormSet.has(norm)) {
        overlapSystems.push(s);
      } else {
        diagramOnly.push(s);
      }
    }

    const diff: DiffStats = {
      inventoryCount: invNormSet.size,
      diagramCount: diagNormSet.size,
      overlapCount: overlapNorms.size,
      inventoryOnlyNorms,
      diagramOnly,
      overlapSystems,
    };

    setDiffStats(diff);
  }, [inventorySystemsNorm, diagramSystems]);

  // ---- Truth candidates (engine for future matching) ----
  const truthCandidates: TruthCandidate[] = (() => {
    if (!diffStats) return [];

    const candidates: TruthCandidate[] = [];

    for (const norm of diffStats.inventoryOnlyNorms) {
      const display = inventoryDisplayByNorm[norm] || norm || "(unknown)";
      candidates.push({
        id: `inv:${norm}`,
        source: "inventory",
        displayName: display,
        normalizedName: norm,
      });
    }

    for (const s of diffStats.diagramOnly) {
      candidates.push({
        id: `dia:${s.id}`,
        source: "diagram",
        displayName: s.name,
        normalizedName: s.normalizedName,
      });
    }

    return candidates.slice(0, 50);
  })();

  function handleTruthDecision(id: string, decision: TruthDecision) {
    setTruthDecisions((prev) => ({
      ...prev,
      [id]: decision,
    }));
  }

  function confidenceForCandidate(c: TruthCandidate): {
    label: string;
    pct: number;
  } {
    if (c.source === "diagram") {
      return { label: "Medium", pct: 70 };
    }
    return { label: "High", pct: 90 };
  }

  // ---- Truth rows (REAL data: inventory + diagram overlap) ----
  const truthRows: {
    inventoryName: string;
    diagramName: string;
    normalizedName: string;
    recommendedSide: "inventory" | "diagram";
    confidencePct: number;
  }[] = (() => {
    if (!diffStats) return [];

    // Pick a "best" diagram system per normalized name (highest integration count).
    const bestDiagramByNorm = new Map<string, DiagramSystem>();

    for (const s of diffStats.overlapSystems) {
      const norm = s.normalizedName;
      if (!norm) continue;
      const existing = bestDiagramByNorm.get(norm);
      if (!existing || s.integrationCount > existing.integrationCount) {
        bestDiagramByNorm.set(norm, s);
      }
    }

    const rows: {
      inventoryName: string;
      diagramName: string;
      normalizedName: string;
      recommendedSide: "inventory" | "diagram";
      confidencePct: number;
    }[] = [];

    for (const [norm, diag] of bestDiagramByNorm.entries()) {
      const inventoryName =
        inventoryDisplayByNorm[norm] || norm || "(unknown)";
      const diagramName = diag.name || norm;

      const invClean = inventoryName.trim().toLowerCase();
      const diaClean = diagramName.trim().toLowerCase();
      const same = invClean === diaClean;

      // For now we assume the diagram label is the recommended canonical name.
      const recommendedSide: "inventory" | "diagram" =
        diagramName && diagramName.trim().length > 0 ? "diagram" : "inventory";

      // Very simple heuristic: exact match = higher confidence.
      const confidencePct = same ? 96 : 88;

      rows.push({
        inventoryName,
        diagramName,
        normalizedName: norm,
        recommendedSide,
        confidencePct,
      });
    }

    // Sort: mismatches first, then by confidence.
    rows.sort((a, b) => {
      const aMismatch =
        a.inventoryName.trim().toLowerCase() ===
        a.diagramName.trim().toLowerCase()
          ? 0
          : 1;
      const bMismatch =
        b.inventoryName.trim().toLowerCase() ===
        b.diagramName.trim().toLowerCase()
          ? 0
          : 1;

      if (bMismatch !== aMismatch) return bMismatch - aMismatch;
      return b.confidencePct - a.confidencePct;
    });

    return rows.slice(0, 25);
  })();

  // ---- Inventory upload ----
  async function handleInventoryUpload(file: File) {
    setUploadingInv(true);
    setInvError(null);

    try {
      console.log("[TECH-STACK] Inventory upload started", {
        projectId,
        fileName: file.name,
      });

      if (!file.name.toLowerCase().endsWith(".csv")) {
        throw new Error(
          "Unsupported file type. Please export your Excel inventory as CSV and upload the .csv file.",
        );
      }

      const text = await file.text();
      const parsed = parseInventoryCsv(text);

      const stats: InventoryStatsLocal = {
        projectId,
        rowCount: parsed.rows.length,
        uniqueSystems: parsed.uniqueSystems,
      };

      setInvStats(stats);
      setInventoryRows(stats.rowCount);
      setNormalizedApps(stats.uniqueSystems);

      setArtifactCount((prev) =>
        stats.rowCount > 0 ? Math.max(prev, 1) : prev,
      );

      const normSet = new Set<string>();
      const displayMap: Record<string, string> = {};
      for (const item of parsed.rows) {
        const displayName = item.systemName || "";
        const norm = normalizeSystemName(displayName);
        if (!norm) continue;
        normSet.add(norm);
        if (!displayMap[norm] && displayName) {
          displayMap[norm] = displayName;
        }
      }
      setInventorySystemsNorm(Array.from(normSet));
      setInventoryDisplayByNorm(displayMap);

      console.log("[TECH-STACK] Inventory parsed locally", {
        rowCount: stats.rowCount,
        uniqueSystems: stats.uniqueSystems,
      });
    } catch (err: any) {
      console.error("[TECH-STACK] Inventory upload failed (client parse)", err);
      setInvError(err?.message ?? "Inventory upload failed.");
      setInventorySystemsNorm([]);
      setInventoryDisplayByNorm({});
    } finally {
      setUploadingInv(false);
    }
  }

  // ---- Lucid upload ----
  async function handleLucidUpload(file: File) {
    setUploadingLucid(true);
    setDeError(null);
    setDiffError(null);

    try {
      const resp = await uploadLucidCsv(projectId, file);
      console.log("[TECH-STACK] Lucid upload success", resp);

      const stats = await fetchDigitalEnterpriseStats(projectId);
      if (stats) {
        setDeStats(stats);
      }

      try {
        const res = await fetch(
          `/api/digital-enterprise/systems?project=${encodeURIComponent(
            projectId,
          )}`,
          { cache: "no-store" },
        );
        if (res.ok) {
          const json = await res.json();
          if (json && Array.isArray(json.systems)) {
            const systems: DiagramSystem[] = json.systems.map((s: any) => ({
              id: String(s.id ?? s.name ?? s.normalizedName ?? "unknown"),
              name: String(s.name ?? "Unknown"),
              normalizedName: String(
                s.normalizedName ?? normalizeSystemName(s.name),
              ),
              integrationCount: Number(s.integrationCount ?? 0),
            }));
            setDiagramSystems(systems);
          } else {
            setDiagramSystems([]);
          }
        } else {
          const text = await res.text().catch(() => "");
          console.error(
            "[TECH-STACK] Failed to refresh diagram systems after Lucid upload",
            res.status,
            text,
          );
        }
      } catch (err: any) {
        console.error(
          "[TECH-STACK] Error refreshing diagram systems after Lucid upload",
          err,
        );
      }

      setArtifactCount((prev) => Math.max(prev, 1));
    } catch (err: any) {
      console.error("[TECH-STACK] Lucid upload failed", err);
      setDeError(err?.message ?? "Lucid upload failed.");
    } finally {
      setUploadingLucid(false);
    }
  }

  const hasDE =
    !!deStats &&
    ((deStats.systemsFuture ?? 0) > 0 ||
      (deStats.integrationsFuture ?? 0) > 0);

  // ---- Render ----
  return (
    <div className="px-8 py-10 max-w-6xl mx-auto">
      <WorkspaceHeader
        statusLabel="STATUS"
        title="Tech Stack Workspace"
        description="Upload inventories, diagrams, and Lucid exports to understand your applications, integrations, and dependencies."
      />

      {/* Inputs description */}
      <Card className="mb-4">
        <p className="text-[0.65rem] tracking-[0.25em] text-gray-500 mb-1 uppercase">
          INPUTS
        </p>
        <p className="text-xs text-gray-500">
          Upload artifacts to build a live view of your digital enterprise for
          project <span className="font-medium">{projectId}</span>.
        </p>
      </Card>

      {/* Upload panels */}
      <FileUploadPanel
        title="UPLOAD INVENTORY SPREADSHEET"
        helper="Export your technology inventory from Excel as CSV and upload it here. We'll parse systems and normalize them for comparison."
        label={uploadingInv ? "Uploading..." : "Upload Inventory CSV"}
        onFileSelected={handleInventoryUpload}
        className="mb-4"
      />

      <FileUploadPanel
        title="UPLOAD LUCID CSV"
        helper="Upload a Lucid CSV export of your architecture diagram. We'll infer systems and integrations automatically and update the Digital Enterprise metrics."
        label={uploadingLucid ? "Uploading..." : "Upload Lucid CSV"}
        onFileSelected={handleLucidUpload}
      />

      {/* Inventory / artifact metrics */}
      <div className="mb-8 grid grid-cols-1 sm:grid-cols-3 gap-4 mt-6">
        <MetricCard
          label="ARTIFACTS"
          value={formatNumber(artifactCount)}
          description="Inventory and diagram files in this project."
        />
        <MetricCard
          label="INVENTORY ROWS"
          value={formatNumber(inventoryRows)}
          description="Application rows ingested from spreadsheets."
        />
        <MetricCard
          label="NORMALIZED APPS"
          value={formatNumber(normalizedApps)}
          description="Systems clustered into canonical applications from inventory."
        />
      </div>

      {invError && (
        <div className="mb-4 text-xs text-red-500">{invError}</div>
      )}

      {/* Digital Enterprise preview */}
      <Card className="mb-8">
        <p className="text-[0.65rem] tracking-[0.25em] text-gray-500 mb-1 uppercase">
          DIGITAL ENTERPRISE PREVIEW
        </p>
        <p className="text-xs text-gray-500 mb-4">
          Derived from your Lucid architecture diagram. Systems and integrations
          here represent the structural view of your ecosystem.
        </p>
        {loadingDE && (
          <div className="text-sm text-gray-500">
            Loading Digital Enterprise preview...
          </div>
        )}
        {!loadingDE && deError && (
          <div className="text-sm text-red-500">{deError}</div>
        )}
        {!loadingDE && !deError && hasDE && deStats && (
          <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
            <MetricCard
              label="SYSTEMS"
              value={formatNumber(deStats.systemsFuture)}
              description="Unique labeled systems in this diagram."
            />
            <MetricCard
              label="INTEGRATIONS"
              value={formatNumber(deStats.integrationsFuture)}
              description="System-to-system connections from Lucid connector lines."
            />
            <MetricCard
              label="DOMAINS DETECTED"
              value={formatNumber(deStats.domainsDetected ?? 0)}
              description="Domain clustering will be introduced in a later iteration."
            />
          </div>
        )}
        {!loadingDE && !deError && !hasDE && (
          <div className="text-sm text-gray-500">
            No Digital Enterprise metrics yet. Upload a Lucid CSV to populate
            this preview.
          </div>
        )}
      </Card>

      {/* TRUTH PASS (PREVIEW) – REAL data, Fuxi recommendation highlighted */}
      <Card className="mt-6">
        <p className="text-[0.65rem] tracking-[0.25em] text-gray-500 mb-1 uppercase">
          TRUTH PASS (PREVIEW)
        </p>
        <p className="text-xs text-gray-500 mb-4">
          Fuxi&apos;s first pass at lining up your inventory systems with the
          Lucid diagram for project {projectId}. Use this as a sanity check
          before trusting the diff.
        </p>

        {diffError && (
          <div className="mb-3 text-xs text-red-500">{diffError}</div>
        )}

        {truthRows.length === 0 ? (
          <p className="text-xs text-gray-500">
            Upload an inventory CSV and a Lucid CSV for this project to see
            Fuxi&apos;s first-pass matches.
          </p>
        ) : (
          <div className="rounded-2xl border border-gray-200 bg-white overflow-hidden">
            <div className="grid grid-cols-3 gap-4 px-4 py-2 text-[0.65rem] tracking-[0.22em] text-gray-500 uppercase bg-slate-50">
              <span>Inventory</span>
              <span>Diagram</span>
              <span className="text-right">Decision</span>
            </div>

            <div className="divide-y divide-gray-100">
              {truthRows.map((row, i) => {
                const inventoryRecommended = row.recommendedSide === "inventory";
                const diagramRecommended = row.recommendedSide === "diagram";

                const inventoryClass = inventoryRecommended
                  ? "font-semibold text-slate-900"
                  : "font-medium text-slate-500";
                const diagramClass = diagramRecommended
                  ? "font-semibold text-slate-900"
                  : "font-medium text-slate-500";

                return (
                  <div
                    key={row.normalizedName + ":" + i}
                    className="grid grid-cols-3 gap-4 px-4 py-3 text-sm items-center"
                  >
                    {/* Inventory name */}
                    <div className="flex items-center">
                      <span className={inventoryClass}>
                        {row.inventoryName}
                      </span>
                    </div>

                    {/* Diagram / recommended name */}
                    <div className="flex items-center gap-2">
                      <span className={diagramClass}>{row.diagramName}</span>
                      {diagramRecommended && (
                        <span className="rounded-full bg-emerald-50 px-2 py-0.5 text-[0.65rem] font-medium text-emerald-700">
                          Recommended
                        </span>
                      )}
                    </div>

                    {/* Confidence + actions */}
                    <div className="flex items-center justify-end gap-3">
                      <span className="inline-flex items-center rounded-full bg-slate-900 px-3 py-1 text-[0.7rem] font-medium text-white">
                        {row.confidencePct}%
                      </span>
                      <button className="px-2.5 py-1 rounded-md bg-gray-100 text-[0.7rem] font-medium text-gray-700 hover:bg-gray-200">
                        Keep
                      </button>
                      <button className="px-2.5 py-1 rounded-md bg-gray-100 text-[0.7rem] font-medium text-gray-700 hover:bg-gray-200">
                        Edit
                      </button>
                      <button className="px-2.5 py-1 rounded-md bg-gray-100 text-[0.7rem] font-medium text-red-600 hover:bg-gray-200">
                        Delete
                      </button>
                    </div>
                  </div>
                );
              })}
            </div>

            <div className="border-t border-slate-100 bg-slate-50 px-4 py-2 text-[0.7rem] text-slate-500">
              Preview only — decisions not yet saved.
            </div>
          </div>
        )}
      </Card>
    </div>
  );
}
